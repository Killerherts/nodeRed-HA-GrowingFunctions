[
  {
    "id": "54825be9f507927b",
    "type": "inject",
    "z": "1f9ff542be636aa9",
    "name": "",
    "props": [
      {
        "p": "payload"
      },
      {
        "p": "topic",
        "vt": "str"
      }
    ],
    "repeat": "60",
    "crontab": "",
    "once": false,
    "onceDelay": 0.1,
    "topic": "",
    "payload": "",
    "payloadType": "date",
    "x": 270,
    "y": 100,
    "wires": [
      [
        "b7b40814c4fec103"
      ]
    ]
  },
  {
    "id": "b7b40814c4fec103",
    "type": "function",
    "z": "1f9ff542be636aa9",
    "name": "Feed By WC",
    "func": "// Constants for Home Assistant Entity IDs\nconst ENTITY_IDS = {\n    highestSoilSensor: 'input_number.highest_soil_sensor_value_side_1',\n    generative: 'input_boolean.side1_generative_steering',\n    flipToFlower: 'input_boolean.side1_filp_to_flower',\n    lightOnTime: 'input_datetime.side_1_lights_on_time',\n    soilMoisture: 'sensor.soil_sesor_a1_moisture_wc',\n    maintenancePhase: 'input_boolean.side1_maintance_phase',\n    feedPumpSwitch: 'switch.side_1_feed_pump_switch'\n};\n\n// Other Constants\nconst SECONDS_IN_DAY = 24 * 60 * 60;\nconst MIN_IRRIGATION_FREQUENCY = 1 * 60; // 10 minutes in seconds\nconst DESIRED_MOISTURE = 46; // Desired moisture level in water content percentage\nconst P1_THRESHOLD = 2;\nconst P2_THRESHOLD = 5; //dryback % before sending a p2\nconst MAX_DELTA = 18; //max dryback overnight\nconst DELAY_FOR_P1_FEED = 25;  // in seconds\nconst DELAY_FOR_P2_FEED = 35;  // in seconds\nconst debug = true;\n\n\n// For retrieving data:\nlet highestSoilsensorVal = 42.00; //getHAState(ENTITY_IDS.highestSoilSensor);\nlet generative = getHAState(ENTITY_IDS.generative) === 'on';\nlet flipToFlower = getHAState(ENTITY_IDS.flipToFlower) === 'on';\nlet lightOnTime = convertTime(getHAState(ENTITY_IDS.lightOnTime));\nlet soilMoisture = 42.00; //parseFloat(getHAState(ENTITY_IDS.soilMoisture));\nlet maintenancePhase = getHAState(ENTITY_IDS.maintenancePhase) === 'on';\ndebugWarn('maintenacePhase: ' + maintenancePhase)\nlet currentTime = getCurrentTime();\nlet currentTimeUTC = getCurrentTimeUTC();\nlet timeSinceLastIrrigation;\n\n// Calculate parameters\nlet lightOffTime = calculateLightOffTime(flipToFlower, lightOnTime);\nlet irrigationStart = calculateIrrigationStart(generative, lightOnTime);\nlet irrigationEnd = calculateIrrigationEnd(lightOffTime);\nlet lastChangedTimeMs = new Date(global.get('homeassistant').homeAssistant.states[ENTITY_IDS.feedPumpSwitch].last_changed).getTime();\nlet lastChanged = convert_epoch_to_utc_seconds(lastChangedTimeMs);\nlet inIrrigationWindow = checkInIrrigationWindow(currentTime, irrigationStart, irrigationEnd);\n\nif (lastChanged < currentTimeUTC) {\n    timeSinceLastIrrigation = Math.floor(currentTimeUTC - lastChanged);\n} else {\n    timeSinceLastIrrigation = Math.floor((SECONDS_IN_DAY - lastChanged) + currentTimeUTC);\n}\n\n\n// Function to get current time in UTC seconds\nfunction getCurrentTimeUTC() {\n    const now = new Date();\n    const utcSeconds = (now.getUTCHours() * 3600) + (now.getUTCMinutes() * 60) + now.getUTCSeconds();\n    return utcSeconds;\n}\n\n\nfunction convert_epoch_to_utc_seconds(epoch_ms) {\n    const epoch_seconds = epoch_ms / 1000;\n    const seconds_into_day_utc = Math.floor(epoch_seconds % SECONDS_IN_DAY);\n    return seconds_into_day_utc;\n}\n\n\n// Function to convert time2 string\nfunction convertTime(timeString) {\n    let time;\n    let isUtc = false;\n\n    if (!timeString) {\n        time = new Date();\n    } else {\n        time = new Date(timeString);\n        isUtc = timeString.includes(\"Z\") || timeString.includes(\"+\") || timeString.includes(\"-\");\n        if (isNaN(time.getTime())) {\n            time = new Date(\"1970-01-01T\" + timeString + \"Z\");\n            isUtc = true;\n        }\n    }\n\n    let hours, minutes, seconds;\n    if (isUtc) {\n        hours = time.getUTCHours();\n        minutes = time.getUTCMinutes();\n        seconds = time.getUTCSeconds();\n    } else {\n        hours = time.getHours();\n        minutes = time.getMinutes();\n        seconds = time.getSeconds();\n    }\n    return parseInt(hours * 60 * 60) + parseInt(minutes * 60) + parseInt(seconds);\n}\n\n// Function to retrieve state from Home Assistant\nfunction getHAState(state) {\n    return global.get('homeassistant').homeAssistant.states[state].state;\n}\n\n/**\n * Constructs a payload for Home Assistant service calls.\n * \n * @param {string} service - The service to be called (e.g., 'turn_on', 'turn_off').\n * @param {string} domain - The domain of the entity (e.g., 'switch', 'light').\n * @param {string} entity_id - The id of the entity to be acted upon.\n * @param {number} delay - The delay in seconds before the action is performed.\n * @param {object} data - Any additional data to be passed along with the service call.\n * @returns {object} - The constructed payload.\n */\nfunction buildPayload(service, domain, entity_id, delay = null, data = {}) {\n    let payload = {\n        service: service,\n        domain: domain,\n        entity_id: entity_id,\n        data: data\n    };\n\n    let message = {\n        payload: payload\n    };\n\n    if (delay !== null) {\n        message.delay = delay * 1000; // Convert seconds to milliseconds\n    }\n\n    return message;\n}\n// Whenever you want to build a payload in your processControlFlow function:\n// const payload = buildPayload('turn_on', 'switch', 'switch.your_p1_feed_id', DELAY_FOR_P1_FEED);\n\n\n\n// Function to get current time in seconds\nfunction getCurrentTime() {\n    const now = new Date();\n    return now.getSeconds() + (60 * (now.getMinutes() + 60 * now.getHours()));\n}\n\n\n// Function to calculate light off time\nfunction calculateLightOffTime(flipToFlower, lightOnTime) {\n    return flipToFlower ? lightOnTime + 12 * 60 * 60 : lightOnTime + 18 * 60 * 60;\n}\n\n// Function to calculate irrigation start time dynamically based on lights on time\nfunction calculateIrrigationStart(generative, lightOnTime) {\n    let irrigationStart = lightOnTime;\n\n    if (generative) {\n        irrigationStart += 2 * 60 * 60; // Add 2 hours for generative steering\n    } else {\n        // Use a default start time if generative is not enabled\n        irrigationStart += 60 * 60; // Add 1 hour\n    }\n\n    return irrigationStart;\n}\n\n// Function to calculate irrigation end time dynamically based on light off time\nfunction calculateIrrigationEnd(lightOffTime) {\n    return (lightOffTime - 60 * 60) % SECONDS_IN_DAY;\n}\n\n// Function to check if current time is in irrigation window\nfunction checkInIrrigationWindow(currentTime, irrigationStart, irrigationEnd) {\n    if (irrigationStart > irrigationEnd) {\n        return currentTime >= irrigationStart || currentTime <= irrigationEnd;\n    } else {\n        return currentTime >= irrigationStart && currentTime <= irrigationEnd;\n    }\n}\n\n// Process control flow\nfunction logDebugData() {\n    if (debug) {\n        node.warn(\"inIrrigationWindow: \" + inIrrigationWindow);\n        node.warn(\"Generative: \" + generative);\n        node.warn(\"Flip to flower: \" + flipToFlower);\n        node.warn(\"Soil moisture: \" + soilMoisture);\n        node.warn(\"Current time: \" + currentTime);\n        node.warn(\"Irrigation start time: \" + irrigationStart);\n        node.warn(\"Irrigation end time: \" + irrigationEnd);\n        node.warn(\"last Irrigation Run \" + lastChanged);\n        node.warn(\"Highest Sensor Value: \" + highestSoilsensorVal);\n        node.warn(\"Last changed Switch:\" + lastChangedTimeMs + \" ms \" + lastChanged)\n    }\n}\n\n// Modify all your node.warn calls to check the debug flag\nfunction debugWarn(message) {\n    if (debug) {\n        node.warn(message);\n    }\n}\n\nfunction processControlFlow() {\n    let turnOnOutput = null;\n    let delayAndTurnOffOutput = null;\n    let flipBooleanOutput = null;\n    let setInputNumberOutput = null;\n\n    if (timeSinceLastIrrigation < MIN_IRRIGATION_FREQUENCY) {\n        debugWarn(`Last irrigation was less than ${MIN_IRRIGATION_FREQUENCY / 60} minutes ago. Not performing a check now.`);\n        return [null, null, null, null];\n    }\n\n    const moistureDifference = DESIRED_MOISTURE - soilMoisture;\n\n    if (Math.abs(moistureDifference) > MAX_DELTA) {\n        debugWarn(\"Max Dryback Feeding\");\n        turnOnOutput = buildPayload('turn_on', 'switch', ENTITY_IDS.feedPumpSwitch);\n        delayAndTurnOffOutput = buildPayload('turn_off', 'switch', ENTITY_IDS.feedPumpSwitch, DELAY_FOR_P2_FEED);\n    } else if (inIrrigationWindow) {\n        if (!maintenancePhase) {\n            if (moistureDifference <= P1_THRESHOLD || highestSoilsensorVal >= DESIRED_MOISTURE) {\n                debugWarn('P2 Flip Switch');\n                turnOnOutput = buildPayload('turn_on', 'switch', ENTITY_IDS.feedPumpSwitch);\n                delayAndTurnOffOutput = buildPayload('turn_off', 'switch', ENTITY_IDS.feedPumpSwitch, DELAY_FOR_P2_FEED);\n            } else if (moistureDifference > P1_THRESHOLD) {\n                debugWarn('P1 feed');\n                turnOnOutput = buildPayload('turn_on', 'switch', ENTITY_IDS.feedPumpSwitch);\n                delayAndTurnOffOutput = buildPayload('turn_off', 'switch', ENTITY_IDS.feedPumpSwitch, DELAY_FOR_P1_FEED);\n            }\n        } else if (moistureDifference > P2_THRESHOLD) {\n            debugWarn('P2 feed');\n            turnOnOutput = buildPayload('turn_on', 'switch', ENTITY_IDS.feedPumpSwitch);\n            delayAndTurnOffOutput = buildPayload('turn_off', 'switch', ENTITY_IDS.feedPumpSwitch, DELAY_FOR_P2_FEED);\n        }\n    } else {\n        if ((irrigationStart < irrigationEnd && (currentTime > irrigationEnd || currentTime < irrigationStart)) ||\n            (irrigationStart > irrigationEnd && !(currentTime > irrigationStart && currentTime < irrigationEnd))) {\n            if (maintenancePhase == true) {\n                debugWarn(\"Resetting Maintenance Switch\");\n                setInputNumberOutput = buildPayload('set_value', 'input_number', ENTITY_IDS.highestSoilSensor, null, {value:0});  // Reset highestSoilSensor value to 0\n                flipBooleanOutput = buildPayload('turn_off', 'input_boolean', ENTITY_IDS.maintenancePhase);\n            }\n        }\n    }\n\n     return [turnOnOutput, delayAndTurnOffOutput, flipBooleanOutput, setInputNumberOutput];\n}\n\nlogDebugData()\n// Run the processControlFlow function\nreturn processControlFlow();\n",
    "outputs": 4,
    "timeout": "",
    "noerr": 0,
    "initialize": "",
    "finalize": "",
    "libs": [],
    "x": 510,
    "y": 100,
    "wires": [
      [
        "69d9e135e187c899"
      ],
      [
        "421bf29ad54d9896"
      ],
      [
        "275ecd72a1b51e2a"
      ],
      [
        "2a99fbe644e176ea"
      ]
    ],
    "outputLabels": [
      "Turn On Feed",
      "Turn Off Feed",
      "Flip Input Boolean",
      "Set Highest Value Back"
    ]
  },
  {
    "id": "69d9e135e187c899",
    "type": "api-call-service",
    "z": "1f9ff542be636aa9",
    "name": "Call Service Payload Var",
    "server": "",
    "version": 5,
    "debugenabled": true,
    "domain": "{{payload.service_domain}}",
    "service": "{{payload.service}}",
    "areaId": [],
    "deviceId": [],
    "entityId": [
      "{{payload.entity_id}}"
    ],
    "data": "",
    "dataType": "jsonata",
    "mergeContext": "",
    "mustacheAltTags": false,
    "outputProperties": [],
    "queue": "none",
    "x": 1030,
    "y": 40,
    "wires": [
      []
    ]
  },
  {
    "id": "421bf29ad54d9896",
    "type": "delay",
    "z": "1f9ff542be636aa9",
    "name": "",
    "pauseType": "delayv",
    "timeout": "5",
    "timeoutUnits": "seconds",
    "rate": "1000",
    "nbRateUnits": "1",
    "rateUnits": "second",
    "randomFirst": "1",
    "randomLast": "5",
    "randomUnits": "seconds",
    "drop": false,
    "allowrate": false,
    "outputs": 1,
    "x": 800,
    "y": 100,
    "wires": [
      [
        "d761f5c21d0e19d0"
      ]
    ]
  },
  {
    "id": "275ecd72a1b51e2a",
    "type": "api-call-service",
    "z": "1f9ff542be636aa9",
    "name": "Call Service Payload Var",
    "server": "",
    "version": 5,
    "debugenabled": true,
    "domain": "{{payload.service_domain}}",
    "service": "{{payload.service}}",
    "areaId": [],
    "deviceId": [],
    "entityId": [
      "{{payload.entity_id}}"
    ],
    "data": "",
    "dataType": "jsonata",
    "mergeContext": "",
    "mustacheAltTags": false,
    "outputProperties": [],
    "queue": "none",
    "x": 1010,
    "y": 160,
    "wires": [
      []
    ]
  },
  {
    "id": "2a99fbe644e176ea",
    "type": "api-call-service",
    "z": "1f9ff542be636aa9",
    "name": "Call Service Payload Var",
    "server": "",
    "version": 5,
    "debugenabled": true,
    "domain": "{{payload.service_domain}}",
    "service": "{{payload.service}}",
    "areaId": [],
    "deviceId": [],
    "entityId": [
      "{{payload.entity_id}}"
    ],
    "data": "{{payload.value}}",
    "dataType": "json",
    "mergeContext": "",
    "mustacheAltTags": false,
    "outputProperties": [],
    "queue": "none",
    "x": 990,
    "y": 220,
    "wires": [
      []
    ]
  },
  {
    "id": "d761f5c21d0e19d0",
    "type": "api-call-service",
    "z": "1f9ff542be636aa9",
    "name": "Call Service Payload Var",
    "server": "",
    "version": 5,
    "debugenabled": true,
    "domain": "{{payload.service_domain}}",
    "service": "{{payload.service}}",
    "areaId": [],
    "deviceId": [],
    "entityId": [
      "{{payload.entity_id}}"
    ],
    "data": "",
    "dataType": "jsonata",
    "mergeContext": "",
    "mustacheAltTags": false,
    "outputProperties": [],
    "queue": "none",
    "x": 1050,
    "y": 100,
    "wires": [
      []
    ]
  }
]
